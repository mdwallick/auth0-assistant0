'use client'; // Assuming this component needs client-side hooks/interaction

import { useState, useEffect } from 'react';
import { useSWRConfig } from 'swr'; // <-- Import useSWRConfig
import { Button } from '@/components/ui/button';
import { SERVICE_CONFIGS } from '@/lib/services';
import { toast } from 'sonner';
import type { SupportedService } from '@/lib/services';

interface ServiceAuthProps {
  service: SupportedService;
}

export function ServiceAuth({ service }: ServiceAuthProps) {
  const [isActive, setIsActive] = useState(false);
  const [isLoading, setIsLoading] = useState(false); // For button state during operation
  const { mutate } = useSWRConfig(); // <-- Get the mutate function

  // Effect to check initial connection status (remains the same)
  useEffect(() => {
    // Consider adding loading/error state here too
    fetch('/api/auth/me') // Assuming this endpoint correctly reflects linked accounts
      .then(res => {
          if (!res.ok) throw new Error('Failed to fetch user status');
          return res.json();
       })
      .then(data => {
        const connectedServices = data.connected_services || [];
        setIsActive(connectedServices.some((cs: any) => cs.connection === SERVICE_CONFIGS[service].connection));
      })
      .catch(err => {
          console.error("Failed to check initial service status:", err)
          // Optionally show a toast or error state
       });
  }, [service]); // Dependency array is correct

  const handleAuthClick = async () => {
    setIsLoading(true); // Disable button, show loading state

    try {
      // --- Popup Opening Logic (remains the same) ---
      const width = 500;
      const height = 600;
      const left = window.screenX + (window.outerWidth - width) / 2;
      const top = window.screenY + (window.outerHeight - height) / 2;

      //window.location.href = `/api/auth/link?requested_connection=${SERVICE_CONFIGS[service].connection}`
      const popup = window.open(
         // Ensure this URL matches your "start linking" API route
        `/api/auth/link?requested_connection=${SERVICE_CONFIGS[service].connection}`,
        'Auth0 Login',
        `width=${width},height=${height},left=${left},top=${top},toolbar=no,menubar=no`
      );

      if (!popup) {
        throw new Error('Please enable popups for this site');
      }

      // --- Wait for Message from Popup (remains the same logic) ---
      await new Promise((resolve, reject) => {
        const messageHandler = (event: MessageEvent) => {
          // IMPORTANT: Add origin check for security!
          // if (event.origin !== window.location.origin) { // Or your specific allowed origin
          //   console.warn('Message received from unexpected origin:', event.origin);
          //   return;
          // }

          if (event.data.type === 'AUTH_COMPLETE') {
            console.log('AUTH_COMPLETE message received from popup.');
            window.removeEventListener('message', messageHandler);
            resolve(true);
          } else if (event.data.type === 'AUTH_ERROR') {
             console.log('AUTH_ERROR message received from popup.');
            window.removeEventListener('message', messageHandler);
            reject(new Error(event.data.error || 'Unknown error during authentication'));
          }
        };
        window.addEventListener('message', messageHandler);

        // Optional: Add a check interval to see if popup was closed manually
        const intervalId = setInterval(() => {
            if (popup.closed) {
                clearInterval(intervalId);
                window.removeEventListener('message', messageHandler);
                // Don't automatically reject, maybe user just closed it
                // Or reject if no success message was received yet:
                // reject(new Error('Authentication popup closed by user.'));
                console.log('Popup closed without completing auth message.');
            }
        }, 500); // Check every 500ms
      });

      // --- Session Refresh Logic (NEW) ---
      toast.info('Authentication complete. Refreshing your session...'); // Give feedback
      console.log('Auth complete message received. Refreshing session...');

      const refreshResponse = await fetch('/api/auth/update-session', { method: 'POST' });
      const refreshData = await refreshResponse.json(); // Try parsing JSON always

      if (!refreshResponse.ok) {
        // Use error message from API response if available
        throw new Error(refreshData.error || `Failed to refresh session (${refreshResponse.status})`);
      }

      console.log('Session update API call successful.');
      await mutate('/api/auth/session'); // Revalidate useUser cache
      console.log('Client-side user data revalidated.');
      // --- End Session Refresh Logic ---


      // *** Important: Only update UI state *after* successful refresh ***
      setIsActive(true);
      toast.success(`Successfully connected to ${service}! Session updated.`);
      
    } catch (error: any) { // Catch errors from popup opening, message handling, or refresh
      toast.error(`Failed to connect ${service}: ${error.message}`);
      // Ensure UI reflects failure (isActive should remain false or be reset)
      // setIsActive(false); // Reset if needed
    } finally {
      setIsLoading(false); // Re-enable button, hide loading state
    }
  };

  return (
    <div className="flex items-center gap-2 p-2">
      <span className="capitalize">{service}</span>
      {/* Consider showing loading state instead of indicator */}
      {!isLoading && <span className={`w-2 h-2 rounded-full ${isActive ? 'bg-green-500' : 'bg-red-500'}`} />}
      {isLoading && <span className="w-2 h-2 rounded-full bg-yellow-500 animate-pulse" title="Processing..."></span>} {/* Example Loading */}

      <Button variant={isActive ? 'secondary' : 'default'} onClick={handleAuthClick} disabled={isLoading}>
        {isLoading ? 'Processing...' : (isActive ? 'Re-authenticate' : 'Connect')}
      </Button>
    </div>
  );
}